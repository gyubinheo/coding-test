# BFS(Breadth First Search) : 너비 우선 탐색.
# 1. 루트에서 시작한다.
# 2. 자식 노드들을 [1]에 저장한다.
# 3. [1]에 저장된 노드들을 차례로 방문한다. 또한 각각의 자식들을 [2]에 저장한다.
# 4. [2]에 저장된 노드들을 차례로 방문한다. 또한 각각의 자식들을 [3]에 저장한다.
# 5. 위의 과정을 반복한다.
# 6. 모든 노드를 방문하면 탐색을 마친다.

# 대표적으로 백트래킹에 사용. 일반적으로 재귀호출을 사용하여 구현하지만, 단순한 스택 배열로 구현하기도 한다. 구조상 스택 오버플로우를 유의.

# 장점
# 출발노드에서 목표노드까지의 최단 길이 경로를 보장한다.

# 단점
# 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요로 하게 된다.
# 해가 존재하지 않는다면 유한 그래프(finite graph)의 경우에는 모든 그래프를 탐색한 후에 실패로 끝난다.
# 무한 그래프(infinite graph)의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못한다.


from collections import deque


def bfs(v):
    queue = deque([v])
    # v 방문
    visited[v] = True
    # 큐가 빌 때까지
    while queue:
        # 큐에서 노드를 하나 뺌
        v = queue.popleft()
        print(v, end=" ")
        # v의 인접 노드 확인
        for i in graph[v]:
            # i에 방문하지 않았다면
            if not visited[i]:
                # i 방문
                queue.append(i)
                visited[i] = True


graph = [
    [],  # 0
    [2, 3, 4],  # 1
    [1, 5],  # 2
    [1, 6, 7],  # 3
    [1, 8],  # 4
    [2],  # 5
    [3, 9],  # 6
    [3],  # 7s
    [4],  # 8
    [6],  # 9
]
visited = [False] * 10

bfs(1)
